<!DOCTYPE HTML>
<html>
 <head>
  <meta http-equiv=Content-Type content="text/html; charset=utf-8">
  <title>
   Types in Functional Programming
  </title>
  <style type="text/css">
   body { width: 65%; }
   table.defs { width: 100%; }
   th.funccol { width: 40%; }
  </style>
 </head>
 <body>
  <div id="magazine" class="magazine">  
   <button id="prev" class="prev">
    Previous
   </button>
   <button id="next" class="next">
    Next
   </button>

   <div id="first" class="slide">
    <h1>Types and Type Classes in Functional Programming</h1>
    <h2>(Actually, what are functors, monoids, and monads?)</h2>
    <p>
     I am teaching myself functional programming, mostly in Haskell and Scala
     with a little Clojure thrown in.  One of the things I have found most
     confusing is a set of common <span class="emphasize">type classes.</span>
    </p>
    <p class="aside">
     I am very new to this stuff. Please bear with me if I make any errors.
     When reviewing these slides I discovered mistakes that I know I would 
     not have made if I were actively programming in these languages.
    </p>
   </div>

   <div class="slide">
    <h3>Overview</h3>
    <p>
     I've read a number of descriptions and analogies to explain what
     these things are.  I think if you get formally into type theory
     there is an exact answer.
    </p>
    <p>
     I have seen some attempts to compare them to interfaces in
     Java. However, I believe these type definitions operate at a
     higher level of abstraction than Java interfaces.
    </p>
    <p>
     I think a better analogy is to design patterns, in the original
     sense of a vocabulary for describing an approach to solving a
     class of problem rather than necessarily a best practice or a
     specific implementation of a solution.  (Since I wrote this slide
     I have seen them called patterns in a number of places.)
    </p>
   </div>

   <div class="slide">
    <h3>Motivation</h3>
    <p>
     Before getting into technical details we should take a higher
     level look at some of the problems these type classes address.
    </p>
    <h4>Sequencing</h4>
    <p>
     In a language with lazy evaluation you cannot count on the order
     in which things are evaluated and you cannot be sure that
     something will be evaluated only once.  If you are performing a
     pure computation this doesn't affect the results.  If you need
     side effects, such as input or output, it is a problem.
    </p>
    <p>
     Sequencing can be done with a number of these type classes.
     Monads also make it easier to pipeline functions, feeding the
     output of one to the input of another, to create more complex
     computations, possibly handling unforeseen events that occur in
     midstream.  In addition there are methods to lift things into
     their monadic equivalents.
    </p>
   </div>

   <div class="slide">
    <h3>Motivation</h3>
    <h4>Function composition with strong static typing</h4>
     Given a function that returns a type that is the type of a
     parameter to another, function the two functions can be combined
     to produce a third.
     <pre>
      <code>&nbsp;user> (defn add1 [n] (+ 1 n))
       #'user/add1
       user> (defn add2 [n] (+ 2 n))
       #'user/add2
       user> (let [add3 (comp add1 add2)] (add3 4))
       7
       user></code>
     </pre>
     If you try to combine two functions and the leftmost function
     (the one calling the result of the other) doesn't accept the type
     of the rightmost function's return value they cannot be combined.
     Clojure will allow the composition, but you will get a runtime
     error.  Haskell will disallow the composition.
   </div>

   <div class="slide">
    <h3>Type Classes</h3>
    <p>
     Haskell is a simple uncluttered language to describe these things
     in.  It supports the notion of "type classes" and "type
     constructors" which essentially define parameterized types.  So
     List is a type constructor which is an instance of a number of
     type classes, including the ones we will be discussing.  So in a
     sense <br><br>the type [String] which signifies "list of String"
     in Haskell corresponds to the type List&lt;String&gt; in
     Java.<br><br> However, List in Haskell is also an instance of
     functor, and there is no very close analogy to that in Java.
     (Also, for historical reasons, List is a type in its own right in
     Java. In Haskell it is not.)
    </p>
   </div>

   <div class="slide">
    <h3>Summary</h3> 
    These type classes are each defined by a set of functions and a set of 
    rules.
    <br><br>
    Note: One of the reasons I think of these as related to design patterns 
    is that there is nothing <span class="emphasize">in the language</span> 
    that enforces these rules.  
    <table border="1" class="defs">
     <tr>
      <th>
       type class
      </th>
      <th class="funccol">
       functions
      </th>
      <th>
       rules
      </th>
     </tr>
     <tr>
      <td>
       functor
      </td>
      <td>
       fmap
      </td>
      <td>
       fmap id  ==  id<br>
       fmap (f . g)  ==  fmap f . fmap g
      </td>
     </tr>
     <tr>
      <td>
       applicative functor
      </td>
      <td>
       pure<br>
       &lt;*&gt; (sequence and combine computations)
      </td>
      <td>
       &nbsp;
      </td>
     </tr>
     <tr>
      <td>
       monoid
      </td>
      <td>
       empty<br>
       append<br>
       concat<hr>
       (Note: "Append" is misnamed.  It is an associative
       binary operation that combines two monoids in some way. 
       In some cases it behaves as "append." "Empty" is an identity
       value that when combined with another value of the same
       monoidal type yields that value.  "Concat" is a function
       that chains calls to "append.")
      </td>
      <td style="vertical-align: top">
       identity: (append empty x = x)<br>and (append x empty = x) <br>
       associativity: appending y to x and then appending z to that
       is the same as appending z to y and then appending that to x.
      </td>
     </tr>
     <tr>
      <td>
       monad
      </td>
      <td>
       return<br>
       bind<br>
       join<hr>
       (Note: monads can be defined in terms of return and bind, or in terms
       of return, join or flatten, and fmap.)
      </td>
      <td style="vertical-align: top">
       left identity: return a >>= f is the same as f a<br>
       right identity: m >>= return is the same as m<br>
       bind is associative
      </td>
     </tr>
    </table>
   </div>

   <div class="slide">
    <h3>Functor</h3>
     <ol>
      <li>str2float n = read n :: Float
      <li>str2float "1" returns 1.0
      <li><span class="highlight">fmap str2float ["1", "2", "3"] returns [1.0, 2.0, 3.0]</span>
     </ol>
   </div>

   <div class="slide">
    <h3>Applicative Functor</h3>
    Given a function, foo, that converts "1" to 1, 2 to "2" and anything
    else to "bigger"<br>
    <span class="highlight">[foo] &lt;*&gt; [1, 2, 3] returns ["1","2","bigger"]</span>
   </div>

   <div class="slide">
    <h3>Monoid</h3>
    <div class="inner">
     Join containers.<br>
     &gt; x<br>
     [1,2,3]<br>
     &gt; y<br>
     [4,5,6]<br>
     &gt; z<br>
     [7,8,9]<br>
     <span class="highlight">&gt; mconcat [x, y, z]<br>
     [1,2,3,4,5,6,7,8,9]<br></span>
    </div>
   </div>

   <div class="slide">
    <h3>Side trip - function composition</h3>
    <div class="inner">
     <span class="emphasize">Regular function composition assumes parameter and return
     types are the same:</span><br>
     &gt; let add1 n = n + 1<br>
     &gt; let add2 n = n + 2<br>
     &gt; let add3 = add2 . add1<br>
     &gt; add3 2<br>
     5<br><br>
     <span class="emphasize">If they are not the same, trouble ensues:</span><br>
     &gt; let add1 n = Just (n + 1)<br>
     &gt; let add2 n = Just (n + 2)<br>
     &gt; add1 2<br>
     Just 3<br>
     &gt; add2 3<br>
     Just 5<br>
     &gt; let add3 = add1 . add2<br>
     <br>
     &lt;interactive&gt;:82:12:<br>
         No instance for (Num (Maybe a0))<br>
           arising from a use of `add1'<br><br>
    </div>
   </div>

   <div class="slide">
    <h3>Monads</h3>
    <div class="inner">
     <span class="emphasize">Monads allow you to compose functions with 
     differing parameter and return types:</span><br>
     &gt; let add1 n = Just (n + 1)<br>
     &gt; let add2 n = Just (n + 2)<br>
     <div class="highlight">
      &gt; return 1 >>= add1 >>= add2<br>
      Just 4<br><br>  
     </div>
     <span class="emphasize">OR</span><br><br>
     <div class="highlight">
      &gt; let add3 = add1 >=> add2<br>
      &gt; add3 1<br>
      Just 4<br>
     </div>
    </div>
   </div>

   <div class="slide">
    <h2>Characteristics</h2>
    <h3>Functor</h3>
    <div class="box">Functor defines<br>fmap.</div>
    <ol>
     <li>       
      Given a function that converts Strings that represent integers
      to floating point values: <br>
      str2float n = read n :: Float
      <br>
      so: str2float "1" returns: 1.0
     </li>
     <li>
      And a list of Strings that represent integers: <br>
      ["1", "2", "3"]
     </li>
     <li>
      <div class="highlight">
       Then applying fmap to str2float and that list produces a list of Floats: <br>
       [1.0, 2.0, 3.0] 
      </div>
     </li>
    </ol>
   </div>

   <div class="slide">
    <h3>Applicative Functor</h3>
    <div class="box">
     Applicative Functor defines<br><i>pure</i><br>and <i>"&lt;*&gt;"</i><br>
    </div>
     Given a functor containing functions, you can apply those functions to the 
     contents of another functor:
    <ol>
     <li>       
      Given a function:<br>
      &gt; let str2float n = read n :: Float
     </li>
     <li>       
      and another function:<br>
      &gt; let str2plusOne n = (read n) + 1 :: Float
     </li>
     <li>
      And a list of Strings that represent integers: <br>
      ["1", "2", "3"]
     </li>
     <li>
      <div class="highlight">
       &gt; f &lt;*&gt; ["1", "2"]<br>
       [1.0,2.0,2.0,3.0]
      </div>
     </li>
    </ol>
   </div>
  
   <div class="slide">
    <h3>Monoids</h3>
    <div class="box">
     Monoid defines<br>
     mempty <br>
     mappend<br>
     mconcat<br>
    </div>
    Mempty is the identity function.  Mappend is a binary function (sometimes append, but 
    not necesssarily), and Mconcat joins monoids.<br>

    So we can join containers.<br>
    <ul>
     <li>
      &gt; x<br>
      [1,2,3]<br>
     </li>
     <li>
      &gt; y<br>
      [4,5,6]<br>
     </li>
     <li>
      &gt; z<br>
      [7,8,9]<br>
     </li>
     <li>
      <div class="highlight">
       &gt; mappend x y<br>
       [1,2,3,4,5,6]
      </div>
     </li>
     <li>
      <div class="highlight">
       &gt; mconcat [x, y, z]<br>
       [1,2,3,4,5,6,7,8,9]<br>
      </div>
     </li>
    </ul>
   </div>
  
   <div class="slide">
    <h3>Monads</h3>
    <div class="box">
     Monad defines<br>
     return <br>
     bind &gt;&gt;=<br>
     join <br>
     fail &nbsp;&nbsp; (viewed by some as necessary, by others as an ugly hack)<br>  
     sequence &gt;&gt;<br>
      <br>
    </div>
    <div class="inner">
     <br>
     Monads allow you to compose functions with differing parameter and return
     types: <br>
     <h2>(example using "Maybe")</h2>
     a n = n + 1<br>
     b n = n + 2<br>
     c = b . a<br>
     e n = Just (a n)<br>
     f n = Just (b n)<br>
     <div class="highlight">
      g = f >=> e<br>
      &gt; g 3<br>
      Just 6<br>
     </div>
    </div>
   </div>

   <div class="slide">
    <h3>Monads continued</h3>
    <h2>(example using Lists)</h2>
    <div class="inner">
     f :: Integer -> Integer<br>
     f x = x + 1<br>
     <br>
     g :: Integer -> Integer<br>
     g x = x * 2<br>
     <br>
     x y = g (f y)<br>
     y = g . f<br><br>
     <hr>
     f' :: Integer -> [Integer]<br>
     f' x = [x + 1]<br>
     <br>
     g' :: Integer -> [Integer]<br>
     g' x = [x * 2]<br>
     <br>
     x' y = return y >>= f' >>= g' <br>
     y' = f' >=> g'<br>
    </div>
   </div>
  
   <div class="slide">
    <h3>Monads continued</h3>
    <div class="inner">
     One of the most useful features of monads is that they allow you,
     by purely functional means, to cause evaluation to proceed in
     a specified order.  Normally in a non-strict language the program
     does not specify the order in which expressions are evaluated. 
     Any code that has to produce side-effects (e.g. input and output)
     typically depends pretty heavily on order of execution.  The sequence
     operator is the same as the bind operator, &gt;&gt;=, except the function
     on the right hand side ignores its parameter.  <br><br>So if you want "a" to 
     happen and then "b" you write:<br>
     a &gt;&gt; b
    </div> 
   </div>

   <div class="slide">
    <h3>Monad syntactic sugar</h3>
    <div>
     To make this easier to use many languages introduce syntactic sugar. In 
     Haskell this is "do" notation and in Scala it is "for" expressions.  
     <br>
     For example, the highlighted part of this code in scala:
     <pre>
      <code>
       <div class="highlight">
       def z(x: Int) : Option[Int] =
	 for {
	   a <- f(x)
	   b <- g(a)
	 } yield b + 1
       </div>

       def f(x: Int) : Option[Int] = {
         if (x <= 3) Some(x + 1)
         else None
       }

       def g(x: Int) : Option[Int] = {
         Some(x * 2)
       }
      </code>
     </pre>
     is converted by the compiler into this:<br>
     def z(x: Int): Option[Int] = f(x).flatMap(((a) => g(a).map(((b) => b.$plus(1)))));

    </div>
   </div>

   <div class="slide">
    <h3>Monads continued</h3>
    <div class="inner">
     Monads have other useful attributes that I won't go into in depth here.
     One worth mentioning is that monads may be flattened.  That is the purpose
     of the join function.<br><br>
     <div class="highlight">
      &gt; join [[1, 2, 3], [4, 5], [], [6]]<br>
      [1,2,3,4,5,6]
     </div>
    </div> 
   </div> 

   <div class="slide">
    <h3>Things to discuss?</h3>
    <h4>Does Rob really get monadic function composition</h4>
    I very nearly included some bad misinformation in this presentation.
    When, with Chas's help, I caught it, it took me about 20 minutes to
    straighten things out.  Given that, I am not now 100% sure I really
    understand the mechanism or motivation.  Here's what I found:
    <br><br>
    This is ok:
    <pre>
     <code>
      module Main (main)
      where 

      import Control.Monad

      main = do
        print (x ["20"])
        print (y ["20"])

      f :: Integer -> String
      f x = show(x + 1)

      // You can modify f to take a list of Integer 
      // and use that for regular function composition
      f' :: [Integer] -> String
      f' [x] = show(x + 1)

      g :: [String] -> [Integer]
      g [x] = [(read x) * 2]

      // Or you can use bind to extract the value from 
      // the list and join g and f that way
      // <span style="color: purple;">This is the part I am not sure I get.
      // Does it matter that f does not return a monad?</span>
       <span style="font-size: larger; color: blue;">x = g >=> f
      y = f' . g</span>
      $ ghc altcomp
      [1 of 1] Compiling Main             ( altcomp.hs, altcomp.o )
      Linking altcomp ...
      $ ./altcomp 
      "41"
      "41"
      $
     </code>
    </pre>
    This is not:
    <pre>
     <code>
      module Main (main)
      where 

      import Control.Monad

      main = do
        print (x ["20"])
        print (y ["20"])

      f :: Integer -> String
      f x = show(x + 1)

      f' :: [Integer] -> String
      f' [x] = show(x + 1)

      g :: [String] -> [Integer]
      g [x] = [(read x) * 2]

       <span style="font-size: larger; color: blue;">x = g >=> f
      y = f . g</span>

      $ !g
      ghc altcomp
      [1 of 1] Compiling Main ( altcomp.hs, altcomp.o )

      altcomp.hs:21:9:
          Couldn't match expected type `Integer' with actual type `[Integer]'
          Expected type: [String] -> Integer
            Actual type: [String] -> [Integer]
          In the second argument of `(.)', namely `g'
          In the expression: f . g
      $ 
     </code>
    </pre>
   </div> 

   <div class="slide">
    <h3>Things to discuss?</h3>
    <div class="inner">
     <p>
      In poking around the web I have found a lot of tutorials on
      monads, and a lot of advice to the effect that monads are not
      fundamental to Haskell and are not the place to start.  That's
      true.  However, scratch the surface of any Haskell program and
      you are likely to find at least functors if not some of the more
      advanced type classes.  
     </p>
     <p>
      I am curious where these concepts fit in to functional
      programming. Certain concepts are central to functional
      programming in any language, from Lisp, to ML, to Scala, to
      Haskell, and even in the more functional aspects of Ruby and
      Python.  Key among these are map, filter, reduce, lambda and
      their friends.
     </p>
    </div> 
   </div> 

   <div class="slide">
    <h3>Things to discuss? (continued)</h3>
    <div class="inner">
     <p>
      The things described in this presentation seem less ubiquitous.
      My impression, at least is that the following are true:
     </p>
     <ol>
      <li>
       When you start learning Haskell you encounter these concepts
       pretty directly.
      </li>
      <li>
       ML books generally talk about functors, although with a
       slightly different meaning.  They don't tend to mention monads
       (but then, the ML books I own are showing their age in other
       ways, so who knows...)
      </li>
      <li>
       As far as I remember, Odersky didn't mention any of these terms
       in his "Functional Programming Principles in Scala" Coursera
       offering.  However, several of the lessons focused specifically 
       on the underlying principles while avoiding the vocabulary.
      </li>
      <li>
       I don't think I have seen any of these terms used in any Lisp books.
       My gut feeling is that while they are applicable to just about any
       programming environment, their value really comes into play in 
       strongly statically typed languages.
      </li>
     </ol>
    </div> 
   </div> 

   <div class="slide">
    <h3>Worthwhile materials</h3>
    <div class="inner">
     I found the following particularly useful:
     <ol>
      <li><a href="http://learnyouahaskell.com/">Learn You A Haskell For Great Good</a>
      <li><a href="http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf">Brent Yorgey's article in The Monad Reader</a>
      <li><a href="http://blog.sigfpe.com/2007/04/trivial-monad.html">Dan Piponi's simplest monad doc</a>
      <li><a href="http://james-iry.blogspot.com/2007/09/monads-are-elephants-part-1.html">Monads are elephants</a>
      <li><a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">Dan Piponi's "You could have invented monads"</a>
      <li><a href="http://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/">Translation of "you could have invented" to Javascript</a>
     </ol>
    </div> 
   </div> 
   <div class="slide">
    <h3>Equivalence of monad definitions</h3>
    <a href="equiv.html">Equivalence of monad definitions</a>
   </div>

  </div>
 </body>
</html>
